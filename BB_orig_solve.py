"""
Benchmarks heuristics against a given set of instances
(e.g., generated by the =gen_BDD_pair.py= script)

(c) A. Bochkarev, Clemson University, 2019
abochka@clemson.edu
"""

import BDD as exact
import varseq as simpl
from time import time
import BB_search as bb
import heuristics as heu
import numpy as np
import sys
from copy import deepcopy
import argparse as ap
from experiments.misc import log

if __name__ == "__main__":
    parser = ap.ArgumentParser(description="Processes (solves) a list of align-BDD instances (c) A. Bochkarev, Clemson University, 2020",
                               formatter_class=ap.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-i", "--in", action="store", dest="inst_list", help="filename for instances list to process")
    parser.add_argument("-o", "--out", action="store", dest="logfile", help="filename for the log")
    parser.add_argument("-d", "--directory", action="store", dest="inst_dir", help="directory with instances")
    parser.add_argument("-H", "--header", action="store_true", dest="header", help="show header only and exit")
    args = parser.parse_args()

    simpl_heu = dict()
    orig_heu = dict()

    for h in heu.SIMPL_HEU:
        simpl_heu.update({h[0]: h})

    for h in heu.ORIG_HEU:
        orig_heu.update({h[0]: h})

    if args.header:
        log("N","instance","num_type","value",comment="comment")
        # needed for the legend
        log("-1,-1,legend,orig_simpl", comment=orig_heu["orig_simpl"][2])
        log("-1,-1,legend,orig_gsifts1p", comment=orig_heu["orig_gsifts1p"][2])
        exit(0)

    inst_dir = args.inst_dir

    with open(args.inst_list,"r") as inst_list:
        with open(args.logfile,"w") as logf:
            # process instances
            for inst_id in inst_list:
                inst_id = inst_id.rstrip()
                if inst_id == "":
                    continue

                t0=time()
                fnameA = "".join([inst_dir, "A",inst_id,".bdd"])
                fnameB = "".join([inst_dir, "B",inst_id,".bdd"])
                bdd_A = exact.BDD(); bdd_A.load(fnameA)
                bdd_B = exact.BDD(); bdd_B.load(fnameB)

                ######################################################
                ## The simplified problem
                vs_A = simpl.VarSeq(bdd_A.vars, [len(l) for l in bdd_A.layers[:-1]])
                vs_B = simpl.VarSeq(bdd_B.vars, [len(l) for l in bdd_B.layers[:-1]])

                N = len(vs_A)

                # find opts for varseq instance with BB-search
                t0 = time()
                b = bb.BBSearch(vs_A,vs_B)
                status = b.search()
                log(N,inst_id,"simpl_opt_status",1-int(status=="optimal"),outfile=logf, comment=status)
                simpl_obj = b.Ap_cand.size() + b.Bp_cand.size()
                t1 = time()
                simpl_time = t1 - t0

                # testing heuristics for the simplified problem
                ## simple ones: toA, toB, toRandom
                simpl_results = dict({"simpl_BB":[b.Ap_cand.size()+b.Bp_cand.size(), simpl_time, b.Ap_cand.layer_var]})
                ######################################################
                # The original problem
                t0 = time()
                o = b.Ap_cand.layer_var # optimal order found by the BBSearch
                bdd_Aa = bdd_A.align_to(o)
                bdd_Ba = bdd_B.align_to(o)
                oo_simpl_order = bdd_Aa.size() + bdd_Ba.size()

                for heuristic in [orig_heu["orig_simpl"], orig_heu["orig_gsifts1p"]]:
                    t0 = time()
                    s,t_add,v = heuristic[1](bdd_A,bdd_B,simpl_results)
                    t1 = time()
                    log(N,inst_id, heuristic[0]+"_time",t_add+(t1-t0),outfile=logf)
                    log(N,inst_id, heuristic[0]+"_obj",s,outfile=logf)
