#+TITLE: Align-BDD project
#+CATEGORY: a-BDD
#+STARTUP: show2levels

* Immediate TODOs
  - [X] 1: soft cover constraints (general type) -- see the revision notes
  - [X] idea 2a (cross-terms, x1x2, etc.)
  - [ ] idea 2b (function of cross-terms) -- ?
  - [X] =build_cover_DD=: make single overlap version
  - [X] =build_color_DD=: fix the procedure (linear DD growth is doable!)
  - [X] =build_tUFLP_MIP=: revise to single overlap version
  - [X] cross-check DDs with the MIP (simple)
  - [X] fix the bug in cover DD generation (infinite loop?..)
  - [X] cross-check DDs with the MIP (random set)
  - [X] test the align-BDD version.
  - [X] implement color ordering / fix the color-DD order
  - [X] test the new problem (against Gurobi) -- runtimes.
  - [X] special case instance (string): diagram sizes
  - [X] special case (organic thing): dia sizes. Is it max degree?
  - [X] example of 'arbitrarily poor' heuristic.
  - [X] randomized cover-DD builder (random order of nodes)
  - [X] randomized color-DD builder
  - [X] num test
  - [X] Look into =gen_test_p.csv= (dia sizes for various instance gen parameters =p=)
  - [X] check out =gen_test_colors.csv= (different no. of colors for given =n = 15=
  - [ ] check out if the costs are correct for =build_color_DD=.
    I thought it was not assume to include costs at all. How does it pass the tests?..
  - [ ] maybe generate t-UFLP differently?
    distribute the first facility into every bin, and then sort them randomly?

* Current project TODOs
** Softcover: design instances with types
:LOGBOOK:
CLOCK: [2022-01-24 Mon 12:16]--[2022-01-24 Mon 12:40] =>  0:24
:END:
*** DONE Design cover DDs (Bool -> Int)
CLOSED: [2022-01-27 Thu 15:11]
- State "DONE"       from "TODO"       [2022-01-27 Thu 15:11]
:LOGBOOK:
CLOCK: [2022-01-27 Thu 14:31]--[2022-01-27 Thu 14:58] =>  0:27
CLOCK: [2022-01-27 Thu 13:36]--[2022-01-27 Thu 14:18] =>  0:42
CLOCK: [2022-01-26 Wed 19:46]--[2022-01-26 Wed 19:47] =>  0:01
CLOCK: [2022-01-26 Wed 17:42]--[2022-01-26 Wed 18:11] =>  0:29
CLOCK: [2022-01-26 Wed 17:20]--[2022-01-26 Wed 17:41] =>  0:21
CLOCK: [2022-01-26 Wed 17:12]--[2022-01-26 Wed 17:20] =>  0:08
CLOCK: [2022-01-26 Wed 16:21]--[2022-01-26 Wed 16:33] =>  0:12
CLOCK: [2022-01-26 Wed 14:40]--[2022-01-26 Wed 16:21] =>  1:41
CLOCK: [2022-01-26 Wed 14:04]--[2022-01-26 Wed 14:18] =>  0:14
CLOCK: [2022-01-26 Wed 13:45]--[2022-01-26 Wed 13:57] =>  0:12
CLOCK: [2022-01-26 Wed 13:08]--[2022-01-26 Wed 13:43] =>  0:35
CLOCK: [2022-01-24 Mon 15:13]--[2022-01-24 Mon 15:32] =>  0:19
CLOCK: [2022-01-24 Mon 13:16]--[2022-01-24 Mon 14:23] =>  1:07
CLOCK: [2022-01-24 Mon 12:59]--[2022-01-24 Mon 13:10] =>  0:11
CLOCK: [2022-01-24 Mon 12:55]--[2022-01-24 Mon 12:56] =>  0:01
:END:
Check it is correct, technically.
*** DONE Check dia sizes scaling (with and w/o reduction) vs. no of vars in MIP
CLOSED: [2022-01-28 Fri 17:21]
- State "DONE"       from "TODO"       [2022-01-28 Fri 17:21]
:LOGBOOK:
CLOCK: [2022-01-28 Fri 15:30]--[2022-01-28 Fri 16:24] =>  0:54
CLOCK: [2022-01-28 Fri 14:05]--[2022-01-28 Fri 14:42] =>  0:37
CLOCK: [2022-01-28 Fri 13:59]--[2022-01-28 Fri 14:03] =>  0:04
CLOCK: [2022-01-27 Thu 18:57]--[2022-01-27 Thu 19:17] =>  0:20
CLOCK: [2022-01-27 Thu 15:16]--[2022-01-27 Thu 15:26] =>  0:10
CLOCK: [2022-01-27 Thu 15:11]--[2022-01-27 Thu 15:14] =>  0:03
:END:
So, without reduction, I basically create an exponentially sized diagrams. This
makes sense, if I am not smart with this ``forgetting'' nodes (after they have zero
``degrees of freedom'').

However, it is not really bright even in theoretical case of writing down a
reduced dia as well...

*** DONE Repeat the experiment for a more narrow graph type (cavemen?)
CLOSED: [2022-01-28 Fri 20:12]
- State "DONE"       from "TODO"       [2022-01-28 Fri 20:12]
:LOGBOOK:
CLOCK: [2022-01-28 Fri 19:17]--[2022-01-28 Fri 20:12] =>  0:55
CLOCK: [2022-01-28 Fri 18:34]--[2022-01-28 Fri 18:55] =>  0:21
CLOCK: [2022-01-28 Fri 17:21]--[2022-01-28 Fri 17:59] =>  0:38
:END:

*** TODO make improved cover-building algo
:LOGBOOK:
CLOCK: [2022-02-15 Tue 15:09]--[2022-02-15 Tue 15:28] =>  0:19
CLOCK: [2022-02-15 Tue 14:14]--[2022-02-15 Tue 15:05] =>  0:51
CLOCK: [2022-02-15 Tue 13:20]--[2022-02-15 Tue 13:28] =>  0:08
CLOCK: [2022-02-15 Tue 12:09]--[2022-02-15 Tue 12:17] =>  0:08
CLOCK: [2022-02-15 Tue 10:51]--[2022-02-15 Tue 11:54] =>  1:03
CLOCK: [2022-02-14 Mon 18:49]--[2022-02-14 Mon 18:55] =>  0:06
CLOCK: [2022-02-01 Tue 13:36]--[2022-02-01 Tue 13:58] =>  0:22
CLOCK: [2022-01-31 Mon 15:18]--[2022-01-31 Mon 15:29] =>  0:11
CLOCK: [2022-01-31 Mon 14:40]--[2022-01-31 Mon 15:11] =>  0:31
CLOCK: [2022-01-31 Mon 14:12]--[2022-01-31 Mon 14:16] =>  0:04
CLOCK: [2022-01-31 Mon 13:16]--[2022-01-31 Mon 13:35] =>  0:19
:END:
*** TODO Compare runtimes w/o types: BDDs vs naive MIP
*** TODO Add types -- generate CPP instances 
*** TODO Compare runtime: naive MIP vs CPP MIP vs Align-BDD CPP
*** TODO Add reduction step -- check time
** DONE Checking the reviewers' comments
CLOSED: [2022-01-26 Wed 13:08]
- State "DONE"       from              [2022-01-26 Wed 13:08]
:LOGBOOK:
CLOCK: [2022-01-25 Tue 12:52]--[2022-01-25 Tue 13:13] =>  0:21
:END:
** DONE Consider alternative applications
CLOSED: [2022-01-26 Wed 13:08]
- State "DONE"       from              [2022-01-26 Wed 13:08]
:LOGBOOK:
CLOCK: [2022-01-26 Wed 12:44]--[2022-01-26 Wed 13:08] =>  0:24
CLOCK: [2022-01-26 Wed 11:47]--[2022-01-26 Wed 12:42] =>  0:55
CLOCK: [2022-01-25 Tue 13:13]--[2022-01-25 Tue 13:25] =>  0:12
:END:
** TODO Kill already merged branches
 [2020-07-11 Sat 09:49]

- minor_fixes (figures, labels, etc.)
- scal_update (major scal update)

As of beginning of the day <2020-07-11> all of these are merged into =master=
** TODO Clean-up testing code (remove unnecessary, add separate testing)
 [2021-02-19 Fri 12:47]
** TODO add diagram generation tests :UFL:
** TODO Revise tests for key functions
** TODO Requires =gurobi= to run examples :doc:
 [2021-02-06 Sat 17:40]
 [[file:~/projects/align-BDD/UFL.py][file:~/projects/align-BDD/UFL.py]]
** TODO implement =BDD.save()= for a weighted BDD
 [2021-02-22 Mon 12:29]
** TODO Perhaps, =is_equivalent= is a bad name?
 [2021-02-22 Mon 13:48]
 [[file:~/projects/align-BDD/BDD.py]]

 Like, maybe rename to =test_equivalence=. And then =is_equivalent <- test_equivalence()[0]=
** TODO rename =VarSeq.layer_var= into =vars=, I suppose...
 [2021-02-22 Mon 17:52]
** TODO rename =cUFL= (streamlining names)
** TODO let S NOT contain the node itself -- amended later :cUFL:
 [2021-03-22 Mon 18:34]
** TODO figure (1) the order of colors and (2) order of nodes within a color
 [2021-03-30 Tue 13:32]
** TODO Technical description :doc:
   - makefile
   - pytest and testing framework
** TODO maybe instances gallery for tUFL?

** DONE Introduce a proper testing framework
CLOSED: [2022-01-19 Wed 14:16]
- State "DONE"       from "TODO"       [2022-01-19 Wed 14:16]
** CANCELED Structure the code into a package + submodules
CLOSED: [2022-01-19 Wed 14:16]
** DONE Move =are_equivalent= method to =BDD.py=
   CLOSED: [2020-08-13 Thu 11:14]
 [2020-08-12 Wed 12:07]
 [[file:~/projects/align-BDD/experiments/BDD_size_illustration/BDD_size_illustration.py::B.load("./sample_5var_inst.bdd")]]
** DONE Maybe look into Sphinx?.. Or what is the best practice?         :doc:
CLOSED: [2022-01-19 Wed 14:15]
- State "DONE"       from "TODO"       [2022-01-19 Wed 14:15]

* Notes
  - revision notes:  [[mu4e:msgid:CO1PR01MB658375A8FEDC337330803037DE609@CO1PR01MB6583.prod.exchangelabs.com][Two ideas]] from JCS.
  - first submission corresponds to =master= commit =04a5b38=
